## 1. 왜 깔끔하게 짜야 하나?

* 처음부터 수정하기 쉽게 짜지 않으면 이후에 많은 비용이 발생하며, 앞부분에 시간을 들이는 것보다 더 들 수 있다. 

* 사용되는 코드는 10번 이상 읽힌다. 빨리 돌아가게 만드는 것보다 잘 읽을 수 있게 만들어야 한다.

* 개발 완료 후 시간을 따로 내어 코드를 수정하겠다는 것은 리팩토링이 아니라 리스트럭처링이다. 이거 아무도 안 한다.

* 구현에 바로 돌입하기보다 종이나 화이트보드에 대략적인 설계를 그려놓고 시작하는 것이 장기적으로는 더 좋다.

## 2. 객체 지향 vs. 절차 지향

| 구분 | 절차 지향 (Procedural Programming) | 객체 지향 (Object-Oriented Programming, OOP) |
| :--- | :--- | :--- |
| **구조** | 데이터가 중앙에 있고, 함수들이 이 데이터를 공유하여 사용함. | 데이터와 이를 사용하는 기능이 객체 내부에 캡슐화되어 있음. |
| **변경 영향** | 데이터 변경 시 데이터를 공유하는 **매우 많은** 함수와 시스템에 영향 발생 (높은 결합도, 낮은 응집도). | 데이터 변경 시 **해당 객체 내부**에만 영향 발생 (높은 응집도, 낮은 결합도). |
| **난이도** | 초기에 진입하기 **쉬움**. | 사고방식의 전환이 필요하여 상대적으로 어려움. |

**결론:** 단순한 이벤트성 시스템이 아니라 계속 유지보수가 필요하거나, 시간이 지남에 따라 복잡해지는 회사 코드는 **무조건 OOP**로 설계해야 함.

## 3. 객체 지향의 핵심 원칙 및 설계

### 3.1 역할과 책임 (Role & Responsibility)

*   역할은 시스템 사용자(예: 글쓰기 사용자, 운영자) 그룹과 관련되며, 책임은 그 역할을 만족시키기 위해 제공되어야 하는 연관 기능
*   클래스 이름은 **무엇이 되고 역할이 보이며 무엇을 하는지**를 보여줘야 합니다 (예: `RequestParser`가 좋고, `JsonRequestParser`는 나쁠 수 있음).

### 3.2 캡슐화 (Encapsulation)

*   내부의 변화가 외부에 영향을 주면 안 됨.
*   내부 상태를 외부에 노출하지 않아야 합니다 (Public 필드나 과도한 Getter/Setter 지양).
*   **"내장을 까서 보지 마라" (Tell, Don't Ask):** 다른 객체의 상태를 가져와 내가 판단하는 것이 아니라, 객체에게 직접 상태를 질의해야 합니다 (예: `expire 됐니?`라고 물어봐야 함). 이는 조건 변경 시 외부 코드 전체를 수정해야 하는 문제를 방지합니다.
*   **Command-Query Separation (CQS):** 메서드는 상태를 변경하는 **Command**이거나 상태를 반환하는 **Query**여야 하며, 두 기능을 합치면 안 됩니다.

### 3.3 다형성과 재사용 (Polymorphism & Reuse)

*   **재사용의 정의:** 진정한 재사용은 구현 상속(Inheritance)을 통해 `super()`의 기능을 호출하는 것이 아닙니다.
*   **인터페이스를 통한 프로그래밍:** **인터페이스(Interface)에 대고 코딩**해야 합니다. 이를 통해 클라이언트 코드가 구체적인 구현체 대신 추상화된 인터페이스에 의존하게 됩니다.
*   **인터페이스의 장점:**
    1.  유연성: 저수준 로직(예: 데이터 파싱, 저장 방식)의 구현체가 변경되거나 새로운 클래스가 추가되어도 고수준 비즈니스 로직(인터페이스를 사용하는 코드)은 영향을 받지 않습니다.
    2.  테스트 용이성: 인터페이스를 사용하면 테스트 시 구현체를 Mock으로 쉽게 대체할 수 있습니다.

## 4. 설계 기술과 테스트

*   **추상화 유지:** 개발자들은 상세한 구현(디렉토리에서 파일 읽기 등)에 빠지기 쉬우므로, **상위 수준의 설계 (추상화)**를 놓치지 않도록 주의해야 함.
*   **의존성 관리:** 구체적인 클래스 대신 인터페이스를 사용하고, 이를 주입(DI)받는 것
    *   **DI의 중요성:** 스프링과 같은 IOC 컨테이너를 사용하면, 테스트하고자 하는 클래스가 의존성을 가지고 있는 애들을 목(Mock)으로 만들어 주입하여 **다른 컴포넌트 없이도 테스트가 가능**해짐