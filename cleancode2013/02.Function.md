# 함수 (Function)

## 1. 함수의 기본 원칙 및 크기

*   함수의 **제일 원칙**은 **한 가지 일만 해야 한다**는 것입니다.
*   함수는 더 이상 작아질 수 없을 만큼 **최대한 작아야** 합니다.
    *   과거 1980년대 터미널 화면(24줄 80컬럼)에 보여야 한다는 기준은 이제 적절하지 않습니다.
    *   로버트 C. 마틴(Bob C. Martin)은 심지어 **네 줄짜리 함수**도 언급합니다.
*   작은 함수를 유지하기 위해 `while`, `nested if` 같은 **들여쓰기(Indentation)**를 유발하는 블록 구조를 피해야 합니다.
*   결과적으로 프로그램은 **서술적이고 긴 이름을 갖는 많은 수의 작은 함수들**로 구성됩니다. 함수 이름은 주석(Comment)을 대체하여 의미 전달을 명확히 합니다.

## 2. 큰 함수를 다루는 기법: Extract Method Object (EMO)

*   **함수 추출 원칙:** 함수를 보면 **큰 클래스로 추출할 생각**을 해야 합니다.
*   **EMO의 정의:** 큰 함수는 **하나 이상의 클래스가 숨어 있는 곳**입니다. 큰 함수는 파라미터와 지역 변수들에 동작하는 기능들의 집합이기 때문에 클래스로 추출할 수 있습니다.

## 3. 리팩토링 In Practice (Fitness)
*   **EMO 시작:** 긴 메서드(`testHtml`)를 `TesterHtmlBuilder`와 같은 클래스로 추출합니다.
*   **필드 변수 추출 (Variable Promotion):** 메서드 전체에 걸쳐 사용되는 변수들은 **필드 변수(Field Variable)** 로 추출합니다.
    *   이것은 함수를 더 작은 메서드로 추출할 때 해당 변수들을 **파라미터로 달고 다니는 것**을 방지하여 함수의 간결성을 유지하도록 돕습니다.
    *   또한, 추출하려는 코드 블록이 두 개 이상의 변수를 변경하는 경우 IDE의 자동 추출 기능이 작동하지 않을 수 있는데, 필드 변수화를 통해 추출을 용이하게 합니다.
*   **기계적인 메서드 추출:** 중복된 구조를 찾아 서로 다른 부분을 변수로 추출한 후, 중복된 블록을 새로운 메서드(`includePage`)로 추출합니다.
*   **인라인(Inline) 작업:** 추출 과정에서 생성된 임시 변수들은 더 이상 필요 없으므로 **인라인** 처리하여 제거하고, 괄호({})를 없앨 수 있습니다.
    *   저자는 괄호가 존재하면 그것은 **한 가지 이상의 일을 한다는 징조**이므로, `try-catch`를 제외하고는 가급적 없애야 한다고 강조합니다.
*   **개선사항** 
    * 읽기 쉬워지고, 함수가 자신의 의도를 잘 전달한다.
*  **개선된 원인**
    * 함수는 작아질 수 있는 한 최대한 작아져야 한다
    * 블록이 적어야 함 - if, else, while 등의 블록 내부 1줄
    * indenting이 적어야 함

## 4. '한 가지 일'의 의미 (추상화 수준)

*   **추상화 수준의 통일:** 함수 내의 스텝들은 호출하는 함수 이름보다 **바로 한 단계 낮은 추상화 수준**을 가져야 합니다.
*   **추출의 한계:** **더 이상 추출할 수 없을 때까지** 계속 익스트랙트 메서드를 수행해야 합니다. 추출한 메서드 이름이 밑의 코드를 단순히 **재인용(rephrasing)** 하는 수준에 이르면, 그것이 추상화 수준이 변하지 않는 한계 지점입니다.

## 5. TDD와 연습의 중요성

*   **변화의 속성:** 좋은 변화(TDD, 클린 코드)는 **퇴행하는 속성**이 있기 때문에, 의식하지 않으면 나쁜 쪽으로 돌아가기 쉽습니다.
*   **연습의 필요성:** 좋은 습관이 몸에 배어 위급한 상황에서도 나오게 하려면 **끊임없는 연습**이 필요합니다 (예: 무술의 품새를 1000번 연습하듯).

## 6. 프라임 넘버 예제를 통한 클래스 분리 (EMO 심화)

*   **초기 EMO (임시 명명):** 일단 큰 함수를 `PrintPrimePrinterHelper`와 같은 **임시 이름**을 가진 클래스로 추출합니다. 역할이 명확해지면 나중에 적합한 이름으로 변경합니다.
*   **필드 변수 추출 및 리네임:** 함수 내의 변수들을 필드 변수로 올리고, 알아보기 어려운 변수 이름(예: `M`)을 의미 있는 이름(예: `numberOfPrimes`)으로 변경합니다.
    *   로컬 변수로 스코프가 끝나야 하는 변수들도 일단 다 올린 다음, 나중에 지우는 것이 더 쉽다.

## 7. 책임 분리 및 결합도 감소

*   **메서드 추출:** 프라임 넘버 **생성** 로직과 **출력** 로직이 섞여 있으므로, 출력 로직(`printNumbers`)을 먼저 별도의 메서드로 추출합니다.
*   **인자 처리 (Coupling 감소):** 추출된 `printNumbers` 메서드가 원래 클래스의 필드 변수에 과도하게 의존하는 것을 막기 위해, 필요한 변수들(프라임 배열, 개수 등)을 **파라미터**로 전달하도록 **시그니처를 변경**합니다.
    *   이는 나중에 이 로직을 별도의 클래스로 뺄 때 불필요한 레퍼런스가 넘어가는 것을 막아 **결합도(Coupling)를 낮추는** 작업입니다.
*   **Command-Query Separation (CQS) 적용:** 프라임 넘버를 **생성(Generate)** 하는 메서드는 결과(프라임 배열)를 반환해야 하고, **출력(Print)** 하는 메서드는 상태를 변경하지 않아야 합니다. 생성과 출력이 강하게 엮여 있으면 유연성이 떨어집니다.
*   **프린터 클래스 분리:** 출력에만 사용되는 변수들(예: `linesPerPage`, `columns`)을 로컬 변수나 파라미터로 처리하여 제너레이터 로직과 완전히 분리한 후, `printNumbers` 메서드를 **`NumberPrinter`라는 별도의 클래스로** 추출합니다.

## 8. 최종 구조와 가독성

*   **명명법 개선:** 추출된 클래스 및 메서드에 의미 있는 이름을 부여합니다 (예: `PrimeGenerator`로 리네임, `invoke`를 `generate`나 `print`로 리네임).
*   **최종 산문 코드:** 리팩토링이 완료된 최상위 코드는 마치 **잘 짜여진 산문(Well-written Prose)** 처럼 읽기 좋게 됩니다. (예: 생성자 만들고 -> 생성하고 -> 프린터 만들고 -> 출력)
*   **복잡도 감소:** 전체 라인 수는 증가할지라도, 복잡한 조건문들이 작은 함수로 추출되었기 때문에 코드의 **복잡도(Complexity)는 오히려 낮아집니다**.
*   **독자의 존중:** 코드의 품질은 코드를 **읽을 사람(Reader)** 의 입장에서 판단해야 합니다. 좋은 코드는 유지보수하는 사람들의 시간을 절약해 줍니다.

## 9. 명명과 추상화의 중요성

*   **이름의 역할:** 이름은 코드를 이해하기 위한 **이정표**나 내비게이션 역할을 합니다.
*   **명명 시점:** 처음부터 완벽한 이름을 지으려 하기보다, 코드를 구현하는 과정을 통해 **충분한 정보가 얻어졌을 때** 명확한 이름으로 변경하는 것이 좋습니다.
*   **추출의 재강조:** 함수는 **작을 수 있는 것보다 더 작아야 한다**는 원칙을 다시 한번 강조하며, 코드가 서로 관련 없는 일을 한다면 **서로 다른 클래스**에 존재해야 합니다.
*   **중괄호의 의미:** 중괄호(`{}`)가 보이면, 그것은 **익스트랙트 해야 하는 대상**이 아닌가 의심해 보는 것이 맞습니다.